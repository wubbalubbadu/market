{"ast":null,"code":"'use strict';\n/*!\n * Module dependencies\n */\n\nconst checkEmbeddedDiscriminatorKeyProjection = require('./helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection');\n\nconst get = require('./helpers/get');\n\nconst getDiscriminatorByValue = require('./helpers/discriminator/getDiscriminatorByValue');\n\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\n\nconst clone = require('./helpers/clone');\n/*!\n * Prepare a set of path options for query population.\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\n\nexports.preparePopulationOptions = function preparePopulationOptions(query, options) {\n  const _populate = query.options.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []); // lean options should trickle through all queries\n\n  if (options.lean != null) {\n    pop.filter(p => get(p, 'options.lean') == null).forEach(makeLean(options.lean));\n  }\n\n  return pop;\n};\n/*!\n * Prepare a set of path options for query population. This is the MongooseQuery\n * version\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\n\nexports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {\n  const _populate = query._mongooseOptions.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []); // lean options should trickle through all queries\n\n  if (options.lean != null) {\n    pop.filter(p => get(p, 'options.lean') == null).forEach(makeLean(options.lean));\n  }\n\n  const session = get(query, 'options.session', null);\n\n  if (session != null) {\n    pop.forEach(path => {\n      if (path.options == null) {\n        path.options = {\n          session: session\n        };\n        return;\n      }\n\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n\n  const projection = query._fieldsForExec();\n\n  pop.forEach(p => {\n    p._queryProjection = projection;\n  });\n  return pop;\n};\n/*!\n * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,\n * it returns an instance of the given model.\n *\n * @param {Model}  model\n * @param {Object} doc\n * @param {Object} fields\n *\n * @return {Document}\n */\n\n\nexports.createModel = function createModel(model, doc, fields, userProvidedFields) {\n  model.hooks.execPreSync('createModel', doc);\n  const discriminatorMapping = model.schema ? model.schema.discriminatorMapping : null;\n  const key = discriminatorMapping && discriminatorMapping.isRoot ? discriminatorMapping.key : null;\n  const value = doc[key];\n\n  if (key && value && model.discriminators) {\n    const discriminator = model.discriminators[value] || getDiscriminatorByValue(model, value);\n\n    if (discriminator) {\n      const _fields = clone(userProvidedFields);\n\n      exports.applyPaths(_fields, discriminator.schema);\n      return new discriminator(undefined, _fields, true);\n    }\n  }\n\n  return new model(undefined, fields, {\n    skipId: true,\n    isNew: false,\n    willInit: true\n  });\n};\n/*!\n * ignore\n */\n\n\nexports.applyPaths = function applyPaths(fields, schema) {\n  // determine if query is selecting or excluding fields\n  let exclude;\n  let keys;\n  let keyIndex;\n\n  if (fields) {\n    keys = Object.keys(fields);\n    keyIndex = keys.length;\n\n    while (keyIndex--) {\n      if (keys[keyIndex][0] === '+') {\n        continue;\n      }\n\n      const field = fields[keys[keyIndex]]; // Skip `$meta` and `$slice`\n\n      if (!isDefiningProjection(field)) {\n        continue;\n      }\n\n      exclude = !field;\n      break;\n    }\n  } // if selecting, apply default schematype select:true fields\n  // if excluding, apply schematype select:false fields\n\n\n  const selected = [];\n  const excluded = [];\n  const stack = [];\n  analyzeSchema(schema);\n\n  switch (exclude) {\n    case true:\n      for (const fieldName of excluded) {\n        fields[fieldName] = 0;\n      }\n\n      break;\n\n    case false:\n      if (schema && schema.paths['_id'] && schema.paths['_id'].options && schema.paths['_id'].options.select === false) {\n        fields._id = 0;\n      }\n\n      for (const fieldName of selected) {\n        fields[fieldName] = fields[fieldName] || 1;\n      }\n\n      break;\n\n    case undefined:\n      if (fields == null) {\n        break;\n      } // Any leftover plus paths must in the schema, so delete them (gh-7017)\n\n\n      for (const key of Object.keys(fields || {})) {\n        if (key.startsWith('+')) {\n          delete fields[key];\n        }\n      } // user didn't specify fields, implies returning all fields.\n      // only need to apply excluded fields and delete any plus paths\n\n\n      for (const fieldName of excluded) {\n        fields[fieldName] = 0;\n      }\n\n      break;\n  }\n\n  function analyzeSchema(schema, prefix) {\n    prefix || (prefix = ''); // avoid recursion\n\n    if (stack.indexOf(schema) !== -1) {\n      return [];\n    }\n\n    stack.push(schema);\n    const addedPaths = [];\n    schema.eachPath(function (path, type) {\n      if (prefix) path = prefix + '.' + path;\n      const addedPath = analyzePath(path, type);\n\n      if (addedPath != null) {\n        addedPaths.push(addedPath);\n      } // nested schemas\n\n\n      if (type.schema) {\n        const _addedPaths = analyzeSchema(type.schema, path); // Special case: if discriminator key is the only field that would\n        // be projected in, remove it.\n\n\n        if (exclude === false) {\n          checkEmbeddedDiscriminatorKeyProjection(fields, path, type.schema, selected, _addedPaths);\n        }\n      }\n    });\n    stack.pop();\n    return addedPaths;\n  }\n\n  function analyzePath(path, type) {\n    const plusPath = '+' + path;\n    const hasPlusPath = fields && plusPath in fields;\n\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath];\n    }\n\n    if (typeof type.selected !== 'boolean') return;\n\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath]; // if there are other fields being included, add this one\n      // if no other included fields, leave this out (implied inclusion)\n\n      if (exclude === false && keys.length > 1 && !~keys.indexOf(path)) {\n        fields[path] = 1;\n      }\n\n      return;\n    } // check for parent exclusions\n\n\n    const pieces = path.split('.');\n    let cur = '';\n\n    for (let i = 0; i < pieces.length; ++i) {\n      cur += cur.length ? '.' + pieces[i] : pieces[i];\n\n      if (excluded.indexOf(cur) !== -1) {\n        return;\n      }\n    } // Special case: if user has included a parent path of a discriminator key,\n    // don't explicitly project in the discriminator key because that will\n    // project out everything else under the parent path\n\n\n    if (!exclude && get(type, 'options.$skipDiscriminatorCheck', false)) {\n      let cur = '';\n\n      for (let i = 0; i < pieces.length; ++i) {\n        cur += (cur.length === 0 ? '' : '.') + pieces[i];\n        const projection = get(fields, cur, false) || get(fields, cur + '.$', false);\n\n        if (projection && typeof projection !== 'object') {\n          return;\n        }\n      }\n    }\n\n    (type.selected ? selected : excluded).push(path);\n    return path;\n  }\n};\n/*!\n * Set each path query option to lean\n *\n * @param {Object} option\n */\n\n\nfunction makeLean(val) {\n  return function (option) {\n    option.options || (option.options = {});\n    option.options.lean = val;\n  };\n}\n/*!\n * Handle the `WriteOpResult` from the server\n */\n\n\nexports.handleDeleteWriteOpResult = function handleDeleteWriteOpResult(callback) {\n  return function _handleDeleteWriteOpResult(error, res) {\n    if (error) {\n      return callback(error);\n    }\n\n    const mongooseResult = Object.assign({}, res.result);\n\n    if (get(res, 'result.n', null) != null) {\n      mongooseResult.deletedCount = res.result.n;\n    }\n\n    if (res.deletedCount != null) {\n      mongooseResult.deletedCount = res.deletedCount;\n    }\n\n    return callback(null, mongooseResult);\n  };\n};","map":{"version":3,"names":["checkEmbeddedDiscriminatorKeyProjection","require","get","getDiscriminatorByValue","isDefiningProjection","clone","exports","preparePopulationOptions","query","options","_populate","populate","pop","Object","keys","reduce","vals","key","concat","lean","filter","p","forEach","makeLean","preparePopulationOptionsMQ","_mongooseOptions","session","path","projection","_fieldsForExec","_queryProjection","createModel","model","doc","fields","userProvidedFields","hooks","execPreSync","discriminatorMapping","schema","isRoot","value","discriminators","discriminator","_fields","applyPaths","undefined","skipId","isNew","willInit","exclude","keyIndex","length","field","selected","excluded","stack","analyzeSchema","fieldName","paths","select","_id","startsWith","prefix","indexOf","push","addedPaths","eachPath","type","addedPath","analyzePath","_addedPaths","plusPath","hasPlusPath","pieces","split","cur","i","val","option","handleDeleteWriteOpResult","callback","_handleDeleteWriteOpResult","error","res","mongooseResult","assign","result","deletedCount","n"],"sources":["/Users/juliachu/Dropbox/CS/market/node_modules/mongoose/lib/queryhelpers.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies\n */\n\nconst checkEmbeddedDiscriminatorKeyProjection =\n  require('./helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection');\nconst get = require('./helpers/get');\nconst getDiscriminatorByValue =\n  require('./helpers/discriminator/getDiscriminatorByValue');\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\nconst clone = require('./helpers/clone');\n\n/*!\n * Prepare a set of path options for query population.\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptions = function preparePopulationOptions(query, options) {\n  const _populate = query.options.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop.\n      filter(p => get(p, 'options.lean') == null).\n      forEach(makeLean(options.lean));\n  }\n\n  return pop;\n};\n\n/*!\n * Prepare a set of path options for query population. This is the MongooseQuery\n * version\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {\n  const _populate = query._mongooseOptions.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop.\n      filter(p => get(p, 'options.lean') == null).\n      forEach(makeLean(options.lean));\n  }\n\n  const session = get(query, 'options.session', null);\n  if (session != null) {\n    pop.forEach(path => {\n      if (path.options == null) {\n        path.options = { session: session };\n        return;\n      }\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n\n  const projection = query._fieldsForExec();\n  pop.forEach(p => {\n    p._queryProjection = projection;\n  });\n\n  return pop;\n};\n\n/*!\n * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,\n * it returns an instance of the given model.\n *\n * @param {Model}  model\n * @param {Object} doc\n * @param {Object} fields\n *\n * @return {Document}\n */\nexports.createModel = function createModel(model, doc, fields, userProvidedFields) {\n  model.hooks.execPreSync('createModel', doc);\n  const discriminatorMapping = model.schema ?\n    model.schema.discriminatorMapping :\n    null;\n\n  const key = discriminatorMapping && discriminatorMapping.isRoot ?\n    discriminatorMapping.key :\n    null;\n\n  const value = doc[key];\n  if (key && value && model.discriminators) {\n    const discriminator = model.discriminators[value] || getDiscriminatorByValue(model, value);\n    if (discriminator) {\n      const _fields = clone(userProvidedFields);\n      exports.applyPaths(_fields, discriminator.schema);\n      return new discriminator(undefined, _fields, true);\n    }\n  }\n\n  return new model(undefined, fields, {\n    skipId: true,\n    isNew: false,\n    willInit: true\n  });\n};\n\n/*!\n * ignore\n */\n\nexports.applyPaths = function applyPaths(fields, schema) {\n  // determine if query is selecting or excluding fields\n  let exclude;\n  let keys;\n  let keyIndex;\n\n  if (fields) {\n    keys = Object.keys(fields);\n    keyIndex = keys.length;\n\n    while (keyIndex--) {\n      if (keys[keyIndex][0] === '+') {\n        continue;\n      }\n      const field = fields[keys[keyIndex]];\n      // Skip `$meta` and `$slice`\n      if (!isDefiningProjection(field)) {\n        continue;\n      }\n      exclude = !field;\n      break;\n    }\n  }\n\n  // if selecting, apply default schematype select:true fields\n  // if excluding, apply schematype select:false fields\n\n  const selected = [];\n  const excluded = [];\n  const stack = [];\n\n  analyzeSchema(schema);\n\n  switch (exclude) {\n    case true:\n      for (const fieldName of excluded) {\n        fields[fieldName] = 0;\n      }\n      break;\n    case false:\n      if (schema &&\n          schema.paths['_id'] &&\n          schema.paths['_id'].options &&\n          schema.paths['_id'].options.select === false) {\n        fields._id = 0;\n      }\n\n      for (const fieldName of selected) {\n        fields[fieldName] = fields[fieldName] || 1;\n      }\n      break;\n    case undefined:\n      if (fields == null) {\n        break;\n      }\n      // Any leftover plus paths must in the schema, so delete them (gh-7017)\n      for (const key of Object.keys(fields || {})) {\n        if (key.startsWith('+')) {\n          delete fields[key];\n        }\n      }\n\n      // user didn't specify fields, implies returning all fields.\n      // only need to apply excluded fields and delete any plus paths\n      for (const fieldName of excluded) {\n        fields[fieldName] = 0;\n      }\n      break;\n  }\n\n  function analyzeSchema(schema, prefix) {\n    prefix || (prefix = '');\n\n    // avoid recursion\n    if (stack.indexOf(schema) !== -1) {\n      return [];\n    }\n    stack.push(schema);\n\n    const addedPaths = [];\n    schema.eachPath(function(path, type) {\n      if (prefix) path = prefix + '.' + path;\n\n      const addedPath = analyzePath(path, type);\n      if (addedPath != null) {\n        addedPaths.push(addedPath);\n      }\n\n      // nested schemas\n      if (type.schema) {\n        const _addedPaths = analyzeSchema(type.schema, path);\n\n        // Special case: if discriminator key is the only field that would\n        // be projected in, remove it.\n        if (exclude === false) {\n          checkEmbeddedDiscriminatorKeyProjection(fields, path, type.schema,\n            selected, _addedPaths);\n        }\n      }\n    });\n\n    stack.pop();\n    return addedPaths;\n  }\n\n  function analyzePath(path, type) {\n    const plusPath = '+' + path;\n    const hasPlusPath = fields && plusPath in fields;\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath];\n    }\n\n    if (typeof type.selected !== 'boolean') return;\n\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath];\n\n      // if there are other fields being included, add this one\n      // if no other included fields, leave this out (implied inclusion)\n      if (exclude === false && keys.length > 1 && !~keys.indexOf(path)) {\n        fields[path] = 1;\n      }\n\n      return;\n    }\n\n    // check for parent exclusions\n    const pieces = path.split('.');\n    let cur = '';\n    for (let i = 0; i < pieces.length; ++i) {\n      cur += cur.length ? '.' + pieces[i] : pieces[i];\n      if (excluded.indexOf(cur) !== -1) {\n        return;\n      }\n    }\n\n    // Special case: if user has included a parent path of a discriminator key,\n    // don't explicitly project in the discriminator key because that will\n    // project out everything else under the parent path\n    if (!exclude && get(type, 'options.$skipDiscriminatorCheck', false)) {\n      let cur = '';\n      for (let i = 0; i < pieces.length; ++i) {\n        cur += (cur.length === 0 ? '' : '.') + pieces[i];\n        const projection = get(fields, cur, false) || get(fields, cur + '.$', false);\n        if (projection && typeof projection !== 'object') {\n          return;\n        }\n      }\n    }\n\n    (type.selected ? selected : excluded).push(path);\n    return path;\n  }\n};\n\n/*!\n * Set each path query option to lean\n *\n * @param {Object} option\n */\n\nfunction makeLean(val) {\n  return function(option) {\n    option.options || (option.options = {});\n    option.options.lean = val;\n  };\n}\n\n/*!\n * Handle the `WriteOpResult` from the server\n */\n\nexports.handleDeleteWriteOpResult = function handleDeleteWriteOpResult(callback) {\n  return function _handleDeleteWriteOpResult(error, res) {\n    if (error) {\n      return callback(error);\n    }\n    const mongooseResult = Object.assign({}, res.result);\n    if (get(res, 'result.n', null) != null) {\n      mongooseResult.deletedCount = res.result.n;\n    }\n    if (res.deletedCount != null) {\n      mongooseResult.deletedCount = res.deletedCount;\n    }\n    return callback(null, mongooseResult);\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}